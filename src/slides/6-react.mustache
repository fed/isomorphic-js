<section>
  <section data-background="http://i.imgur.com/STg3tNs.jpg"></section>

  <section>
    <h2>Rendering on both the client and the server</h2>
    <pre><code>
// server.js
var server = express();
server.use(function (req, res) {
var markup = ReactDOMServer.renderToString(&lt;App />);
var html = injectIntoHtml({ app: markup });
res.send(html);
});

// client.js
ReactDOM.render(&lt;App />, document.getElementById('app'));
    </code></pre>
  </section>

  <section>
    <h2>Sharing state</h2>
    <p>aka: having the client pick up where the server left off (e.g.: avoid hitting the same API endpoint twice).</p>
    <pre><code>
// server.js
server.use(function (req, res) {
var state = {};
fetchData(function(err, data) {
state.data = data;
var exposedState = 'window.__STATE__=' + JSON.stringify(state) + ';';
var markup = ReactDOMServer.renderToString(&lt;App data={data} />);
var html = injectIntoHtml({ app: markup, state: exposedState });
res.send(html);
});
});

// client.js
var state = window.__STATE__;
ReactDOM.render(&lt;App data={state.data} />, document.getElementById('app'));
    </code></pre>
  </section>

  <section>
    <h2>Sharing state (cont'd)</h2>
    <ul>
      <li>Serialize state on the server and pass it over to the client (aka: Rehydration)</li>
      <li>On the server, the app state is bound to each request, i.e. there is one state per request (since a server serves multiple client requests). On the client, the app state is global, i.e. we only need one state for the whole browser session.</li>
    </ul>
  </section>

  <section>
    <h2>Handling multiple routes</h2>
    <p>On the server, we can simply get the route by matching the request URL against our route manifest:</p>
    <pre><code>
// server.js
server.use(function (req, res) {
var route = matchPath(req.url);
var markup = ReactDOMServer.renderToString(&lt;App route={route} />);
var html = injectIntoHtml({ app: markup });
res.send(html);
});
    </code></pre>
  </section>

  <section>
    <h2>Handling multiple routes (cont'd)</h2>
    <p>On the client, we use the path from the browser's URL (location API) to match a route:</p>
    <pre><code>
// client.js
function render(route) {
ReactDOM.render(&lt;App route={route} />, document.getElementById('app'));
}

// first render
var route = matchPath(getCurrentPath());
render(route);

// re-render on browser location change
addLocationChangeListener(function (path) {
var route = matchPath(path);
render(route);
});
    </code></pre>
  </section>

  <section>
    <h2>Putting all pieces together</h2>
    <p>On the server, we match the route and attach it to the app state. We then fetch the required data, render the app and send the markup back.</p>
    <pre><code>
// server.js
server.use(function(req, res) {
var state = {};
var route = matchPath(req.url);
state.route = route;

fetchData(route, function (err, data) { // takes data as an argument
state.data = data;
var exposedState = 'window.__STATE__=' + JSON.stringify(state) + ';';
var markup = ReactDOMServer.renderToString(&lt;App route={route} data={data} />);
var html = injectIntoHtml({ app: markup, state: exposedState });
res.send(html);
});
});
    </code></pre>
  </section>

  <section>
    <h2>Putting all pieces together (cont'd)</h2>
    <pre><code>
// client.js
var state = window.__STATE__;

function render() {
ReactDOM.render(
&lt;App route={state.route} data={state.data} />,
document.getElementById('app')
);
}

// first render, server already fetched all data for us
render();

// re-render on browser location change, we do need to fetch new data here
addLocationChangeListener(function (path) {
var route = matchPath(path);
state.route = route;
render(); // render immediately with no/old data

// fetch data in the background then re-render
fetchData(route, function (err, data) {
merge(state.data, data);
render();
});
});
    </code></pre>
  </section>

  <section>
    <h2>Turning isomorphism off</h2>
    <p>The server just needs to send the serialized config in an empty HTML page (that contains a link to the JS app bundle), and the client will take care of the rest</p>
    <pre><code>
// config.js
var config = {
  DISABLE_ISO: process.env.DISABLE_ISO
};
    </code></pre>
  </section>

  <section>
    <h2>Turning isomorphism off (cont'd)</h2>
    <pre><code>
// server.js
server.use(function (req, res) {
  if (config.DISABLE_ISO) {
    var exposedConfig = 'window.__CONFIG__=' + JSON.stringify(config) + ';';
    var html = injectIntoHtml({
      config: exposedConfig
    });
    res.send(html);
  } else {
    var state = {};
    // check session, fetch data, render app,
    // expose state & config, send html...
  }
});
    </code></pre>
  </section>

  <section>
    <h2>Turning isomorphism off (cont'd)</h2>
    <pre><code>
// client.js
var config = window.__CONFIG__;
api.useConfig(config);

var state;
// first render
if (config.DISABLE_ISO) {
  state = {};
  var route = matchPath(getCurrentPath());
  state.route = route;
  // render immediately with no data (can show a loading spinner)
  state.data = {};
  render();
  // fetch data in the background then re-render
  fetchData(route, function (err, data) {
    merge(state.data, data);
    render();
  });
} else {
  state = window.__STATE__;
  render();
}

// add browser location change listener...
    </code></pre>
  </section>

  <section>
    <h2>Progressive enhancement</h2>
    <p>What if we "turned off" the client-side portion? That would probably mean disabling JavaScript in the browser, and "going back" to the good old request/response cycle where every route is rendered on the server.</p>
    <p>The bare-minimum of Progressive Enhancement is to be able to go from one route to another with JS turned off. This means using actual link tags (&lta>) with their href attribute defined (this is also important for accessibility). When JS is enabled, you can intercept the click event on the &lta> elements to prevent a page refresh and handle the routing on the client.</p>
  </section>

  <section>
    <h2>Progressive enhancement (cont'd)</h2>
    <pre><code>
var Link = React.createClass({
  render: function () {
    return (
      &lta {...this.props} onClick={this.handleClick}>{this.props.children}&lt/a>
    );
  },
  handleClick: function(e) {
    e.preventDefault(); // It's all about intercepting when JS is enabled
    navigateTo(this.props.href);
  }
});
    </code></pre>
  </section>

  <section>
    <h2>Progressive enhancement (cont'd)</h2>
    <pre><code>
var NewContact = React.createClass({
  getInitialState: function () {
    return { loading: false };
  },
  render: function() {
    &ltform action="/contacts/create" onSubmit={this.handleSubmit}>
      &ltinput ref="name" name="name" />
      &ltbutton type="submit" disabled={this.state.loading}>Create&lt/button>
      {this.state.loading ? 'Loading...' : null} // Enhancement if JS is enabled
    &lt/form>
  },
  handleSubmit: function (e) {
    e.preventDefault();
    this.setState({ loading: true });
    var name = this.refs.name.getDOMNode().value;
    navigateTo('/contact/create?name=' + urlEncode(name));
  }
});
    </code></pre>
  </section>
</section>
